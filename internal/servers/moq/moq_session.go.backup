package moq

import (
	"context"
	"encoding/binary"
	"fmt"
	"io"
	"strings"
	"time"
	
	"github.com/quic-go/webtransport-go"
	
	"github.com/bluenviron/mediamtx/internal/defs"
	"github.com/bluenviron/mediamtx/internal/logger"
	"github.com/bluenviron/mediamtx/internal/protocols/moq/message"
	"github.com/bluenviron/mediamtx/internal/stream"
	"github.com/bluenviron/mediamtx/internal/unit"
)

// moqSession handles a MoQ session over WebTransport
type moqSession struct {
	server  *Server
	session *webtransport.Session
	ctx     context.Context
	cancel  context.CancelFunc
	
	// MoQ state
	role         message.Role
	version      uint64
	isSetup      bool
	subscriptions map[string]bool  // track subscriptions
	
	// MediaMTX stream connection
	path   defs.Path
	stream *stream.Stream
}

// newMoQSession creates a new MoQ session handler
func newMoQSession(server *Server, wtSession *webtransport.Session) *moqSession {
	ctx, cancel := context.WithCancel(context.Background())
	return &moqSession{
		server:        server,
		session:       wtSession,
		ctx:           ctx,
		cancel:        cancel,
		subscriptions: make(map[string]bool),
	}
}

// run handles the MoQ protocol session
func (s *moqSession) run() {
	defer s.session.CloseWithError(0, "session ended")
	defer s.cancel()
	
	remoteAddr := s.session.RemoteAddr()
	s.server.Log(logger.Info, "[MoQ] Session started from %s", remoteAddr)
	
	// Try to accept control stream with timeout
	acceptChan := make(chan *webtransport.Stream, 1)
	errChan := make(chan error, 1)
	
	go func() {
		stream, err := s.session.AcceptStream(s.ctx)
		if err != nil {
			errChan <- err
		} else {
			acceptChan <- stream
		}
	}()
	
	var controlStream *webtransport.Stream
	select {
	case stream := <-acceptChan:
		controlStream = stream
		s.server.Log(logger.Info, "[MoQ] Control stream accepted")
	case err := <-errChan:
		s.server.Log(logger.Error, "[MoQ] Failed to accept control stream: %v", err)
		return
	case <-time.After(10 * time.Second):
		s.server.Log(logger.Error, "[MoQ] Timeout waiting for control stream")
		return
	}
	defer controlStream.Close()
	
	// Handle MoQ setup (it will read the message type itself)
	if err := s.handleSetup(controlStream); err != nil {
		s.server.Log(logger.Error, "[MoQ] Setup failed: %v", err)
		return
	}
	
	// Main message loop
	for {
		select {
		case <-s.ctx.Done():
			return
		default:
			// Read next message
			msgType, err := s.readVarInt(controlStream)
			if err != nil {
				if err != io.EOF {
					s.server.Log(logger.Error, "[MoQ] Failed to read message type: %v", err)
				}
				return
			}
			
			s.server.Log(logger.Debug, "[MoQ] Received message type: %d", msgType)
			
			// Handle message based on type
			switch msgType {
			case 0x03: // SUBSCRIBE
				if err := s.handleSubscribe(controlStream); err != nil {
					s.server.Log(logger.Error, "[MoQ] Subscribe failed: %v", err)
					return
				}
				
			case 0x06: // ANNOUNCE
				if err := s.handleAnnounce(controlStream); err != nil {
					s.server.Log(logger.Error, "[MoQ] Announce failed: %v", err)
					return
				}
				
			default:
				s.server.Log(logger.Warn, "[MoQ] Unknown message type: %d", msgType)
				// Skip unknown message
			}
		}
	}
}

// handleSetup processes the MoQ SETUP message
func (s *moqSession) handleSetup(stream io.ReadWriter) error {
	// Read message type first
	msgType, err := s.readVarInt(stream)
	if err != nil {
		return fmt.Errorf("failed to read message type: %w", err)
	}
	
	if msgType != 0x01 {
		return fmt.Errorf("expected SETUP (0x01), got 0x%x", msgType)
	}
	
	// Read version
	version, err := s.readVarInt(stream)
	if err != nil {
		return fmt.Errorf("failed to read version: %w", err)
	}
	
	// Read role
	role, err := s.readVarInt(stream)
	if err != nil {
		return fmt.Errorf("failed to read role: %w", err)
	}
	
	s.server.Log(logger.Info, "[MoQ] SETUP received - version: 0x%x, role: %d", version, role)
	
	// Store session state with defaults for testing
	s.version = 0xFF000001  // draft-01
	s.role = message.RoleSubscriber
	s.isSetup = true
	
	// Send SETUP response
	// Message Type (0x01 for SETUP)
	if err := s.writeVarInt(stream, 0x01); err != nil {
		return fmt.Errorf("failed to write setup type: %w", err)
	}
	
	// Version (draft version)
	if err := s.writeVarInt(stream, 0xFF000001); err != nil {  // draft-01
		return fmt.Errorf("failed to write version: %w", err)
	}
	
	// Role (0x01 for publisher)
	if err := s.writeVarInt(stream, 0x01); err != nil {
		return fmt.Errorf("failed to write role: %w", err)
	}
	
	s.server.Log(logger.Info, "[MoQ] SETUP response sent")
	return nil
}

// handleSubscribe processes SUBSCRIBE messages
func (s *moqSession) handleSubscribe(stream io.ReadWriter) error {
	// Read subscribe ID
	subscribeID, err := s.readVarInt(stream)
	if err != nil {
		return fmt.Errorf("failed to read subscribe ID: %w", err)
	}
	
	// Read track alias
	trackAlias, err := s.readVarInt(stream)
	if err != nil {
		return fmt.Errorf("failed to read track alias: %w", err)
	}
	
	// Read namespace
	namespace, err := s.readString(stream)
	if err != nil {
		return fmt.Errorf("failed to read namespace: %w", err)
	}
	s.server.Log(logger.Debug, "[MoQ] Namespace raw: '%s' (len=%d)", namespace, len(namespace))
	
	// Read track name
	trackName, err := s.readString(stream)
	if err != nil {
		return fmt.Errorf("failed to read track name: %w", err)
	}
	s.server.Log(logger.Debug, "[MoQ] Track raw: '%s' (len=%d)", trackName, len(trackName))
	
	s.server.Log(logger.Info, "[MoQ] SUBSCRIBE received - ID: %d, alias: %d, namespace: '%s', track: '%s'", 
		subscribeID, trackAlias, namespace, trackName)
	
	// Store subscription
	subKey := fmt.Sprintf("%s/%s", namespace, trackName)
	s.subscriptions[subKey] = true
	
	// Send SUBSCRIBE_OK response
	// Message Type (0x04 for SUBSCRIBE_OK)
	if err := s.writeVarInt(stream, 0x04); err != nil {
		return fmt.Errorf("failed to write subscribe_ok type: %w", err)
	}
	
	// Subscribe ID
	if err := s.writeVarInt(stream, subscribeID); err != nil {
		return fmt.Errorf("failed to write subscribe ID: %w", err)
	}
	
	// Expires (0 = never)
	if err := s.writeVarInt(stream, 0); err != nil {
		return fmt.Errorf("failed to write expires: %w", err)
	}
	
	s.server.Log(logger.Info, "[MoQ] SUBSCRIBE_OK sent for %s", subKey)
	
	// Start sending media data for this subscription
	go s.startMediaStream(trackAlias, namespace, trackName)
	
	return nil
}

// handleAnnounce processes ANNOUNCE messages
func (s *moqSession) handleAnnounce(stream io.ReadWriter) error {
	// Read namespace
	namespace, err := s.readString(stream)
	if err != nil {
		return fmt.Errorf("failed to read namespace: %w", err)
	}
	
	s.server.Log(logger.Info, "[MoQ] ANNOUNCE received for namespace: %s", namespace)
	
	// Send ANNOUNCE_OK
	// Message Type (0x07 for ANNOUNCE_OK)
	if err := s.writeVarInt(stream, 0x07); err != nil {
		return fmt.Errorf("failed to write announce_ok type: %w", err)
	}
	
	// Namespace
	if err := s.writeString(stream, namespace); err != nil {
		return fmt.Errorf("failed to write namespace: %w", err)
	}
	
	return nil
}

// startMediaStream starts streaming media data for a subscription
func (s *moqSession) startMediaStream(trackAlias uint64, namespace, trackName string) {
	s.server.Log(logger.Info, "[MoQ] Starting media stream for %s/%s", namespace, trackName)
	
	// Open a unidirectional stream for media data
	// OpenUniStreamSync opens a unidirectional stream
	stream, err := s.session.OpenUniStreamSync(s.ctx)
	if err != nil {
		s.server.Log(logger.Error, "[MoQ] Failed to open media stream: %v", err)
		return
	}
	defer stream.Close()
	
	s.server.Log(logger.Info, "[MoQ] Unidirectional stream opened for media data")
	
	// Try to connect to the actual MediaMTX stream
	pathName := namespace
	if pathName == "" || pathName == "/" {
		pathName = "mystream" // default to mystream for testing
	}
	
	// Clean up the path name - trim any non-alphanumeric prefix/suffix
	pathName = strings.TrimSpace(pathName)
	if pathName == "" {
		pathName = "mystream"
	}
	
	// Request to read from the path
	if s.server.PathManager != nil {
		s.server.Log(logger.Info, "[MoQ] Attempting to connect to MediaMTX stream: %s", pathName)
		
		// Create reader request (similar to HLS muxer)
		path, mtxStream, err := s.server.PathManager.AddReader(defs.PathAddReaderReq{
			Author: s,
			AccessRequest: defs.PathAccessRequest{
				Name:     pathName,
				SkipAuth: true,  // Skip authentication for now
			},
		})
		if err != nil {
			s.server.Log(logger.Warn, "[MoQ] Failed to connect to stream %s: %v", pathName, err)
			// Fall back to test data
			s.sendTestFrames(stream, trackAlias)
			return
		}
		
		// Store the path even if stream is nil
		s.path = path
		s.stream = mtxStream
		
		s.server.Log(logger.Info, "[MoQ] AddReader returned: path=%v, stream=%v", path != nil, mtxStream != nil)
		
		// If stream is nil, we need to wait for it to become available
		// This happens when publisher just connected but hasn't sent data yet
		if s.stream == nil {
			s.server.Log(logger.Info, "[MoQ] Path exists but stream not ready yet, waiting for publisher to send data...")
			
			// We're already registered as a reader on the path
			// Now we need to wait for the stream to be created when the publisher sends data
			// We'll implement a simple polling mechanism since MediaMTX doesn't expose stream ready events
			
			waitStart := time.Now()
			waitTimeout := 10 * time.Second
			checkInterval := 100 * time.Millisecond
			
			// Create a ticker for checking
			ticker := time.NewTicker(checkInterval)
			defer ticker.Stop()
			
			for {
				select {
				case <-s.ctx.Done():
					s.server.Log(logger.Info, "[MoQ] Context cancelled while waiting for stream")
					// Clean up our reader registration
					if s.path != nil {
						removeReq := defs.PathRemoveReaderReq{
							Author: s,
							Res:    make(chan struct{}),
						}
						s.path.RemoveReader(removeReq)
						<-removeReq.Res
					}
					return
					
				case <-ticker.C:
					// Check if timeout reached
					if time.Since(waitStart) > waitTimeout {
						s.server.Log(logger.Error, "[MoQ] Timed out waiting for stream after %v", waitTimeout)
						// Clean up our reader registration
						if s.path != nil {
							removeReq := defs.PathRemoveReaderReq{
								Author: s,
								Res:    make(chan struct{}),
							}
							s.path.RemoveReader(removeReq)
							<-removeReq.Res
						}
						// Send error to client and close
						s.server.Log(logger.Error, "[MoQ] Stream not available, closing connection")
						return
					}
					
					// Try to access the stream through a different approach
					// Since we're already registered, we should check if stream became available
					// Unfortunately MediaMTX doesn't expose the stream directly, so we need a workaround
					
					// Remove ourselves as reader first
					removeReq := defs.PathRemoveReaderReq{
						Author: s,
						Res:    make(chan struct{}),
					}
					s.path.RemoveReader(removeReq)
					<-removeReq.Res
					
					// Try to add ourselves again to get the updated stream
					path2, mtxStream2, err2 := s.server.PathManager.AddReader(defs.PathAddReaderReq{
						Author: s,
						AccessRequest: defs.PathAccessRequest{
							Name:     pathName,
							SkipAuth: true,
						},
					})
					
					if err2 != nil {
						s.server.Log(logger.Debug, "[MoQ] Stream check failed: %v", err2)
						// Path might have been removed, continue waiting
						continue
					}
					
					// Update our references
					s.path = path2
					s.stream = mtxStream2
					
					// Check if we got a stream this time
					if s.stream != nil {
						s.server.Log(logger.Info, "[MoQ] Stream became available after %v", time.Since(waitStart))
						break
					}
					
					// Still no stream, continue waiting
					s.server.Log(logger.Debug, "[MoQ] Still waiting for stream... (%v elapsed)", time.Since(waitStart))
				}
			}
		}
		
		s.server.Log(logger.Info, "[MoQ] Successfully connected to stream, ready to receive H.264 frames")
		
		// Double-check stream is not nil before registering
		if s.stream == nil {
			s.server.Log(logger.Error, "[MoQ] CRITICAL: Stream is still nil after waiting! This shouldn't happen")
			s.sendTestFrames(stream, trackAlias)
			return
		}
		
		// Register our callback to receive frames
		s.registerStreamReader(stream, trackAlias)
		
		// Keep the goroutine alive while streaming
		<-s.ctx.Done()
		
		// Clean up
		if s.path != nil {
			removeReq := defs.PathRemoveReaderReq{
				Author: s,
				Res:    make(chan struct{}),
			}
			s.path.RemoveReader(removeReq)
			<-removeReq.Res
		}
		
	} else {
		s.server.Log(logger.Warn, "[MoQ] PathManager not available, sending test data")
		s.sendTestFrames(stream, trackAlias)
	}
}

// sendTestFrames sends test frames when real stream is not available
func (s *moqSession) sendTestFrames(stream *webtransport.SendStream, trackAlias uint64) {
	groupID := uint64(0)
	objectID := uint64(0)
	frameCount := 0
	
	for {
		select {
		case <-s.ctx.Done():
			return
		case <-time.After(33 * time.Millisecond): // ~30fps
			// Send object header
			// Using simple object format for now
			s.writeVarInt(stream, trackAlias)
			s.writeVarInt(stream, groupID)
			s.writeVarInt(stream, objectID)
			s.writeVarInt(stream, 0) // priority
			
			// Create a more realistic test payload
			// In real implementation, this would be H.264 NAL units
			testData := make([]byte, 1024) // 1KB test frames
			// Add frame header pattern
			testData[0] = 0x00
			testData[1] = 0x00
			testData[2] = 0x00
			testData[3] = 0x01  // NAL start code
			testData[4] = 0x65  // IDR frame type (simulated)
			
			// Add frame counter for debugging
			copy(testData[5:], []byte(fmt.Sprintf("frame_%d_%d_%d", frameCount, groupID, objectID)))
			
			s.writeVarInt(stream, uint64(len(testData)))
			stream.Write(testData)
			
			frameCount++
			objectID++
			if objectID >= 30 { // New group every 30 frames (1 second)
				groupID++
				objectID = 0
			}
			
			if groupID > 10 { // Stream for 10 seconds instead of 5
				s.server.Log(logger.Info, "[MoQ] Test stream completed after %d frames", frameCount)
				return
			}
		}
	}
}

// registerStreamReader registers this session as a reader for the stream
func (s *moqSession) registerStreamReader(moqStream *webtransport.SendStream, trackAlias uint64) {
	if s.stream == nil {
		return
	}
	
	s.server.Log(logger.Info, "[MoQ] Registering as stream reader")
	
	// We'll receive H.264 units through this callback
	groupID := uint64(0)
	objectID := uint64(0)
	frameCount := 0
	
	// Add ourselves as a reader to the stream
	s.stream.AddReader(s, nil, nil, func(u unit.Unit) error {
		// Convert MediaMTX unit to MoQ object
		// Get RTP packets from the unit
		rtpPkts := u.GetRTPPackets()
		if len(rtpPkts) == 0 {
			return nil
		}
		
		// Get the actual H.264 NAL unit data
		data := rtpPkts[0].Payload
		
		// Log first few frames for debugging
		if frameCount < 5 {
			s.server.Log(logger.Info, "[MoQ] Received H.264 frame %d: %d bytes, NAL type: 0x%x", 
				frameCount, len(data), data[0]&0x1F)
		}
		
		// Send as MoQ object
		s.writeVarInt(moqStream, trackAlias)
		s.writeVarInt(moqStream, groupID)
		s.writeVarInt(moqStream, objectID)
		s.writeVarInt(moqStream, 0) // priority
		
		s.writeVarInt(moqStream, uint64(len(data)))
		moqStream.Write(data)
		
		frameCount++
		objectID++
		if objectID >= 30 { // New group every 30 frames (1 second at 30fps)
			groupID++
			objectID = 0
			s.server.Log(logger.Info, "[MoQ] Sent group %d (%d frames)", groupID-1, frameCount)
		}
		
		return nil
	})
	
	// Start reading from the stream
	s.stream.StartReader(s)
}

// Log implements logger.Writer for the Reader interface
func (s *moqSession) Log(level logger.Level, format string, args ...interface{}) {
	s.server.Log(level, "[MoQ Session] "+format, args...)
}

// Close implements the Reader interface
func (s *moqSession) Close() {
	s.cancel()
}

// APIReaderDescribe implements the Reader interface
func (s *moqSession) APIReaderDescribe() defs.APIPathSourceOrReader {
	return defs.APIPathSourceOrReader{
		Type: "moqSession",
		ID:   s.session.RemoteAddr().String(),
	}
}

// Helper functions for varint encoding
func (s *moqSession) readVarInt(r io.Reader) (uint64, error) {
	var buf [8]byte
	if _, err := r.Read(buf[:1]); err != nil {
		return 0, err
	}
	
	// Check the first two bits to determine length
	firstByte := buf[0]
	length := 1 << (firstByte >> 6)
	
	if length > 1 {
		if _, err := r.Read(buf[1:length]); err != nil {
			return 0, err
		}
	}
	
	// Mask off the length bits
	buf[0] &= 0x3F
	
	// Convert to uint64
	var result uint64
	for i := 0; i < length; i++ {
		result = (result << 8) | uint64(buf[i])
	}
	
	return result, nil
}

func (s *moqSession) writeVarInt(w io.Writer, value uint64) error {
	var buf [8]byte
	
	// Determine required length
	var length int
	if value < (1 << 6) {
		length = 1
		buf[0] = byte(value)
	} else if value < (1 << 14) {
		length = 2
		binary.BigEndian.PutUint16(buf[:2], uint16(value))
		buf[0] |= 0x40
	} else if value < (1 << 30) {
		length = 4
		binary.BigEndian.PutUint32(buf[:4], uint32(value))
		buf[0] |= 0x80
	} else {
		length = 8
		binary.BigEndian.PutUint64(buf[:8], value)
		buf[0] |= 0xC0
	}
	
	_, err := w.Write(buf[:length])
	return err
}

func (s *moqSession) readString(r io.Reader) (string, error) {
	length, err := s.readVarInt(r)
	if err != nil {
		return "", err
	}
	
	buf := make([]byte, length)
	if _, err := io.ReadFull(r, buf); err != nil {
		return "", err
	}
	
	return string(buf), nil
}

func (s *moqSession) writeString(w io.Writer, str string) error {
	if err := s.writeVarInt(w, uint64(len(str))); err != nil {
		return err
	}
	_, err := w.Write([]byte(str))
	return err
}